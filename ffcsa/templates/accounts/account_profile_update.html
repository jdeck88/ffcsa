{% extends "pages/page.html" %}
{% load mezzanine_tags shop_tags i18n static %}
{% block body_id %}products{% endblock %}

{% block body_class %}bg-gray-100{% endblock %}


{% block main %}
<main id="accountSettings" v-cloak>
  <!-- Call block super -->
  {{ block.super }}

  <section class="container mx-auto grid gap-4 grid-cols-12">
    <!-- left section -->
    <div class="col-span-12 md:col-span-3  py-3">
      <div class="bg-white">
        <h3 class="text-lg p-4">Settings</h3>
  
        <ul>
          <li :class="[{'bg-gray-200 border-l-4 border-primary': activeSettings == 'personal'}, 'hover:bg-gray-200']">
            <a id="personal" class="block p-4" href="#" @click.prevent="updateActiveSettings">My info</a>
          </li>
          <li :class="[{'bg-gray-200 border-l-4 border-primary': activeSettings == 'payment'}, 'hover:bg-gray-200']">
            <a id="payment" class="block p-4" href="#" @click.prevent="updateActiveSettings">Payment</a>
          </li>
          <li :class="[{'bg-gray-200 border-l-4 border-primary': activeSettings == 'delivery'}, 'hover:bg-gray-200']">
            <a id="delivery" class="block p-4" href="#" @click.prevent="updateActiveSettings">Delivery Options</a>
          </li>
          <li :class="[{'bg-gray-200 border-l-4 border-primary': activeSettings == 'orders'}, 'hover:bg-gray-200']">
            <a id="orders" class="block p-4" href="#" @click.prevent="updateActiveSettings">Order history</a>
          </li>
          <li :class="[{'bg-gray-200 border-l-4 border-primary': activeSettings == 'password'}, 'hover:bg-gray-200']">
            <a id="password" class="block p-4" href="#" @click.prevent="updateActiveSettings">Change Password</a>
          </li>
        </ul>
      </div>
    </div>

    <!-- right section -->
    <div class="col-span-12 md:col-span-9 bg-white p-5">
      <!-- personal settings -->
      <div v-show="activeSettings == 'personal'">
        <h3 class="text-lg">Personal</h3>
  
        <form id="personal-form" class="grid grid-cols-12 gap-4 mt-10">
          <!-- first name -->
          <div class="col-span-6">
            <label for="first_name" class="text-gray-700 px-1">First name</label>
            <input type="text" name="first_name" id="first_name" v-model="user.first_name" class="input-v">
          </div>
  
          <!-- last name -->
          <div class="col-span-6">
            <label for="last_name" class="text-gray-700 px-1">Last name</label>
            <input type="text" name="last_name" id="last_name" v-model="user.last_name" class="input-v">
          </div>
  
          <!-- email -->
          <div class="col-span-12">
            <label for="email" class="text-gray-700 px-1">Email</label>
            <input type="email" name="email" id="email" v-model="user.email" class="input-v">
          </div>
  
          <!-- Contact Number -->
          <div class="col-span-6">
            <label for="phone_number" class="text-gray-700 px-1">Contact Number</label>
            <input type="text" name="phone_number" id="phone_number" v-model="user.profile.phone_number" class="input-v" @input="acceptPhoneNumber" required pattern="[0-9]{3}-[0-9]{3}-[0-9]{4}">
            <small class="text-gray-400">must match format 999-999-9999</small>
          </div>
  
          <!-- Alternate Contact Number -->
          <div class="col-span-6">
            <label for="phone_number_2" class="text-gray-700 px-1">Alternate Contact Number</label>
            <input type="text" name="phone_number_2" id="phone_number_2" v-model="user.profile.phone_number_2" class="input-v" @input="acceptPhoneNumber2" pattern="[0-9]{3}-[0-9]{3}-[0-9]{4}">
            <small class="text-gray-400">must match format 999-999-9999</small>
          </div>
          
        </form>

        <!-- save button -->
        <div class="section-footer flex mt-10">
          <ff-button text="Update info" cls="btn-primary ml-auto mr-3" :loading="personal.loading" v-on:click.native="saveUser"></ff-button>
        </div>
      </div>
      
      <!-- payment -->
      <div v-show="activeSettings == 'payment'">
        <h3 class="text-lg">Payment</h3>
        {% include 'accounts/account_payments.html' %}
      </div>

      <!-- delivery settings -->
      <div v-show="activeSettings == 'delivery'">
        <h3 class="text-lg">Delivery Options</h3>

        <form id="delivery-form" class="grid grid-cols-12 gap-4 my-10">
          <!-- Delivery Options -->
          {% if settings.HOME_DELIVERY_ENABLED %}
          <div class="col-span-12">
            <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
              <input type="checkbox" id="home_delivery" name="home_delivery" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" v-model="user.profile.home_delivery"/>
              <label for="home_delivery" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
            </div>
            <label for="toggle" class="cursor-pointer select-none">Home Delivery</label>
            <small class="block text-gray-400 mt-2">Available in Eugene, Corvallis, and Springfield for a $5 fee. This fee is waived for all orders over $125.</small>
          </div>

          <div class="col-span-12" v-if="user.profile.home_delivery" v-observe-visibility="initAutoCompelete()">
            <label for="address">Address</label>
            <input class="input-v" id="address" type="text" v-model="user.profile.delivery_address" required>
          </div>
          {% endif %}

          <!-- Drop Sites -->
          <div class="col-span-12" v-if="user.profile.home_delivery">
            <label for="drop_site" class="block">Drop Site Location</label>
            <select name="drop_site" id="drop_site" class="input-v" v-model="user.profile.drop_site" required>
              {% for site in DROPSITE_CHOICES %}
              <option value="{{site.0}}">{{site.1}}</option>
              {% endfor %}
            </select>
          </div>

          <!-- Preferences -->
          <h3 class="col-span-12 text-lg mt-6 mb-3">Preferences</h3>
          
          <div class="col-span-6">
            <label class="inline-flex items-center cursor-pointer">
              <input type="checkbox" class="form-radio h-4 w-4 text-gray-600" name="plastic_bags" v-model="user.profile.plastic_bags">
              <span class="ml-2 text-gray-700 select-none">Plastic bags</span>
            </label>
            <small class="block text-gray-400 pl-6">Please pack small items in a plastic bag.</small>
          </div>

          <div class="col-span-6">
            <label class="inline-flex items-center cursor-pointer">
              <input type="checkbox" class="form-radio h-4 w-4 text-gray-600" name="weekly_emails" v-model="user.profile.weekly_emails">
              <span class="ml-2 text-gray-700 select-none">Receive Weekly Emails</span>
            </label>
            <small class="block text-gray-400 pl-6">Receive weekly newsletter and reminder emails.</small>
          </div>
          
          <div class="col-span-12">
            <label class="inline-flex items-center cursor-pointer">
              <input type="checkbox" class="form-radio h-4 w-4 text-gray-600" name="allow_substitutions" v-model="user.profile.allow_substitutions">
              <span class="ml-2 text-gray-700 select-none">Allow substitutions</span>
            </label>
            <small class="block text-gray-400 pl-6 max-w-lg">I am okay with substitutions when an item I ordered is no longer available. We do our best to pack what you have ordered, however on occasion crops will not be ready to harvest, etc. We can provide a substitution, or we can credit your account.</small>
          </div>
        </form>

        <!-- save button -->
        <div class="section-footer flex mt-10">
          <ff-button text="Save changes" cls="btn-primary ml-auto mr-3" :loading="personal.loading" v-on:click.native="saveUser"></ff-button>
        </div>
      </div>

      <!-- order history -->
      <div v-show="activeSettings == 'orders'">
        <h3 class="text-lg">Order history</h3>

        <orders endpoint="/api/orders" class="mt-5"></orders>
      </div>
      
      <!-- change password -->
      <div v-show="activeSettings == 'password'">
        <h3 class="text-lg">Change Password</h3>

        <form id="password-form" class="grid grid-cols-12 gap-4 my-10">

          <div class="col-span-12">
            <label for="cpassword" class="text-gray-700 px-1">Current password</label>
            <input type="password" name="cpassword" id="cpassword" class="input-v delivery_address_part" minlength="6">
          </div>
          <div class="col-span-12">
            <label for="password" class="text-gray-700 px-1">New password</label>
            <input type="password" name="password" id="password" class="input-v delivery_address_part" minlength="6">
          </div>
          <div class="col-span-12">
            <label for="password2" class="text-gray-700 px-1">Confirm new password</label>
            <input type="password" name="password2" id="password2" class="input-v delivery_address_part" minlength="6">
          </div>
        </form>

        <!-- save button -->
        <div class="section-footer flex mt-10">
          <ff-button text="Save changes" cls="btn-primary ml-auto mr-3" :loading="personal.loading" v-on:click.native="changePassword"></ff-button>
        </div>
      </div>
      
    </div>

  </section>

</main>
{% endblock main %}

{% block js %}
<script src="https://unpkg.com/vuetable-2@next"></script>
<script src="https://js.stripe.com/v3/"></script>
<script type="text/javascript" src="https://maps.google.com/maps/api/js?libraries=geometry,places&key={{ settings.GOOGLE_API_KEY }}"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/geocodezip/geoxml3@master/polys/geoxml3.js"></script>

<script defer>

  // Stripe
  const stripe = Stripe('{{ STRIPE_API_KEY }}')
  const elements = stripe.elements({
    fonts: [
      {
        cssSrc: "https://rsms.me/inter/inter.css"
      }
    ],
    // Stripe's examples are localized to specific languages, but if
    // you wish to have Elements automatically detect your user's locale,
    // use `locale: 'auto'` instead.
    locale: window.__exampleLocale
  });

  /**
   * Card Element
   */
  const card = elements.create("card", {
    style: {
      base: {
        color: "#32325D",
        fontWeight: 500,
        fontFamily: "Inter, Open Sans, Segoe UI, sans-serif",
        fontSize: "20px",
        fontSmoothing: "antialiased",

        "::placeholder": {
          color: "#CFD7DF"
        }
      },
      invalid: {
        color: "#E25950"
      }
    }
  });


  // Payment history component
  const PaymentComponent = Vue.component('payments', {
    
    data: function () {
      return {
        payments: [],
        count: 0,
        next: null,
        previous: null,
        limit: 5
      }
    },
    props: ['endpoint'],
    delimiters: ['{', '}'],
    template: `
    <div style="min-height: 30rem;">
      <div class="flex flex-col" style="min-height: 23rem;">
        <div class="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div class="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8">
            <div class="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg">
              <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                  <tr>
                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Date
                    </th>
                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Amount
                    </th>
                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Status
                    </th>
                    <th v-if="!only_payments" scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      notes
                    </th>
                  </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
                  <tr v-for="payment in payments">
                    <td class="px-6 py-4 whitespace-nowrap">{payment.date}</td>
                    <td class="px-6 py-4 whitespace-nowrap">$ {payment.amount}</td>
                    <td class="px-6 py-4 whitespace-nowrap">
                      <!-- Payment pending status -->
                      <span v-if="payment.pending" class="badge bg-red-100 text-red-800">
                        Pending
                      </span>
                      <span v-else class="badge bg-green-100 text-green-800">
                        Success
                      </span>
                      <!-- Payment pending status -->
                    </td>
                    <td v-if="!only_payments" class="px-6 py-4 whitespace-nowrap" style="white-space: break-spaces;">{payment.notes}</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Page pagination -->
      <div v-if="next || previous" class="flex justify-center my-3">
        <a :class="[(previous == null) ? 'pointer-events-none' : '', 'next-prev p-1 pt-2 mr-2']" href="#" @click.prevent="goBack">
          <i class="fas fa-chevron-left"></i>
        </a>

        <template v-for="i in pageRange">
          <p class="mt-1 p-1 mx-1" v-if="i == currentPage">{i}</p>
          <p v-else class="pagination-page mt-1 p-1 mx-1 font-thin">{i}</p>
        </template>

        <a :class="[(next == null) ? 'pointer-events-none' : '', 'next-prev p-1 pt-2 mr-2']" href="#" @click.prevent="goNext">
          <i class="fas fa-chevron-right"></i>
        </a>
      </div>
      <!-- Page pagination -->
    </div>
    `,
    methods: {
      async getPaginatedData(url=`${this.endpoint}?limit=${this.limit}`) {
        // make sure we are not overpassing the count
        if (this.count > 0 && this.offset > this.count) this.offset = this.count - this.limit;
        
        try {
          const res = await axios.get(url);
          this.count = res.data.count;
          this.next = res.data.next;
          this.previous = res.data.previous;
          this.payments = res.data.results;
        } catch (error) {
          console.log(error.response.data)
        }
      },
      goBack() {
        if (!this.previous) return;
        const url = new URL(this.previous)
        this.getPaginatedData(url.pathname + url.search)
      },
      goNext() {
        if (!this.next) return;
        const url = new URL(this.next)
        this.getPaginatedData(url.pathname + url.search)
      }
    },
    computed: {
      pages: function() {
        return Math.ceil(parseInt(this.count) / parseInt(this.limit))
      },
      currentPage: function() {
        return Math.ceil((parseInt(this.offset) + parseInt(this.limit))/ parseInt(this.limit))
      },
      pageRange: function() {
        const pages = Array.from({length: this.pages}, (_, i) => i + 1)
        const index = pages.indexOf(this.currentPage);

        const prev = []
        for (i = index; i > 0; i--) {
          prev.unshift(i)
        }

        const next = []
        for (i = index + 1; i <= pages.length; i++) {
          next.push(i)
        }


        let total = prev.slice(Math.max(prev.length - 3, 0))

        for (item in next) {
          if (total.length < 6) total.push(next[item])
        }

        // console.log('total', total)
        return total
      },
      offset: function() {
        if (!this.next) return 0;
        const url = new URL(this.next);
        const offset = parseInt(url.searchParams.get('offset')) - this.limit;
        return offset
      },
      only_payments: function() {
        return this.endpoint.includes('only_payments')
      }
    
    },
    mounted() {
      this.getPaginatedData() 
    }
  })

  // Order history component
  const OrderComponent = Vue.component('orders', {
    
    data: function () {
      return {
        orders: [],
        count: 0,
        next: null,
        previous: null,
        limit: 10
      }
    },
    props: ['endpoint'],
    delimiters: ['{', '}'],
    template: `
    <div style="min-height: 30rem;">
      <div class="flex flex-col" style="min-height: 23rem;">
        <div class="-my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
          <div class="py-2 align-middle inline-block min-w-full sm:px-6 lg:px-8">
            <div class="shadow overflow-hidden border-b border-gray-200 sm:rounded-lg">
              <table class="min-w-full divide-y divide-gray-200">

                <thead class="bg-gray-50">
                  <tr>
                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Date
                    </th>
                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Order total
                    </th>
                    <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      View invoice
                    </th>
                  </tr>
                </thead>

                <tbody class="bg-white divide-y divide-gray-200">
                  <tr v-for="order in orders">
                    <td class="px-6 py-4 whitespace-nowrap">{new Date(order.time).toLocaleDateString()}</td>
                    <td class="px-6 py-4 whitespace-nowrap">$ {order.total}</td>
                    <td class="px-6 py-4 whitespace-nowrap">
                      <span class="btn-white font-normal text-xs" v-html="order.invoice"></span>
                    </td>
                  </tr>
                </tbody>

              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Page pagination -->
      <div v-if="next || previous" class="flex justify-center my-3">
        <a :class="[(previous == null) ? 'pointer-events-none' : '', 'next-prev p-1 pt-2 mr-2']" href="#" @click.prevent="goBack">
          <i class="fas fa-chevron-left"></i>
        </a>

        <template v-for="i in pageRange">
          <p class="mt-1 p-1 mx-1" v-if="i == currentPage">{i}</p>
          <p v-else class="pagination-page mt-1 p-1 mx-1 font-thin">{i}</p>
        </template>

        <a :class="[(next == null) ? 'pointer-events-none' : '', 'next-prev p-1 pt-2 mr-2']" href="#" @click.prevent="goNext">
          <i class="fas fa-chevron-right"></i>
        </a>
      </div>
      <!-- Page pagination -->
    </div>
    `,
    methods: {
      async getPaginatedData(url=this.endpoint + `?limit=${this.limit}`) {
        // make sure we are not overpassing the count
        if (this.count > 0 && this.offset > this.count) this.offset = this.count - this.limit;

        try {
          const res = await axios.get(url);
          console.log(res)
          this.count = res.data.count;
          this.next = res.data.next;
          this.previous = res.data.previous;
          this.orders = res.data.results;
        } catch (error) {
          console.log(error.response.data)
        }
      },
      goBack() {
        if (!this.previous) return;
        const url = new URL(this.previous)
        this.getPaginatedData(url.pathname + url.search)
      },
      goNext() {
        if (!this.next) return;
        const url = new URL(this.next)
        this.getPaginatedData(url.pathname + url.search)
      }
    },
    computed: {
      pages: function() {
        return Math.ceil(parseInt(this.count) / parseInt(this.limit))
      },
      currentPage: function() {
        return Math.ceil((parseInt(this.offset) + parseInt(this.limit))/ parseInt(this.limit))
      },
      pageRange: function() {
        const pages = Array.from({length: this.pages}, (_, i) => i + 1)
        const index = pages.indexOf(this.currentPage);

        const prev = []
        for (i = index; i > 0; i--) {
          prev.unshift(i)
        }

        const next = []
        for (i = index + 1; i <= pages.length; i++) {
          next.push(i)
        }


        let total = prev.slice(Math.max(prev.length - 3, 0))

        for (item in next) {
          if (total.length < 6) total.push(next[item])
        }

        // console.log('total', total)
        return total
      },
      offset: function() {
        if (!this.next) return 0;
        const url = new URL(this.next);
        const offset = parseInt(url.searchParams.get('offset')) - this.limit;
        return offset
      },
    },
    mounted() {
      this.getPaginatedData() 
    }
  })

  // FF Custom Button (button with spinner)
  const FFButton = Vue.component('ff-button', {
    delimiters: ['{', '}'],
    props: {
      text: String,
      cls: String,
      loading: Boolean
    },
    template: `
      <template v-if="loading == true">
        <button :class="cls.replace('btn-primary', 'btn-white w-32')" disabled>
          <img src="{% static 'gifs/spinner.gif' %}" alt="spinner" class="h-8 m-auto">
        </button>
      </template>
      <template v-else>
        <button :class="cls" type="button">{text}</button>
      </template>
    `,
    data: function() {
      return {}
    }
  })


  const AccountVue = new Vue({
    el: '#accountSettings',
    delimiters: ['((', '))'],
    data: {
      // Current active tab
      activeSettings: 'personal',

      // Personal
      // TODO - might need to update this
      personal: {
        loading: false
      },

      user: {
        first_name: '',
        last_name: '',
        email: '',
        profile: {
          phone_number: '',
          phone_number_2: '',
          home_delivery: false,
          delivery_notes: '',
          drop_site: 'Farm',
          plastic_bags: false,
          weekly_emails: false,
          allow_substitutions: false,
        }
      },

      // Payments
      // oneTimePayment
      // {% if user.profile.non_subscribing_member or user.profile.stripe_subscription_id or user.profile.stripe_customer_id and user.profile.ach_status in 'NEW,VERIFYING' %}
      oneTimePayment: {
        modalShown: false,
        paymentMethod: 'ACH',
        stripeError: null,
        loading: false
      },
      // {% endif %}


      // VerifyACH
      // {% if user.profile.payment_method == 'ACH' and user.profile.ach_status == 'NEW' or user.profile.payment_method == 'ACH' and user.profile.ach_status == 'VERIFYING' %}
      VerifyACH: {
        loading: false
      },
      
      // newSubscription
      // {% elif not user.profile.non_subscribing_member and not user.profile.stripe_subscription_id %}
      newSubscription: {
        paymentMethod: 'ACH', // ACH || CC
        stripeError: null,
        loading: false

      },
      // {% endif %}

    },
    methods: {
      // get user info
      async getUser() {
        try {
          const res = await axios.get(`/api/users/{{user.id}}`);
          console.log(res.data)
          this.user = res.data
        } catch (error) {
          NavVue.show_msg('Can not get user information', 'error')
        }
      },
      // Save user info
      async saveUser() {
        const form = document.getElementById(`${this.activeSettings}-form`);
        if (!form.reportValidity()) return
        
        try {
          this.personal.loading = true
          const res = await axios.patch(`/api/users/{{user.id}}/`, {...this.user});
          NavVue.show_msg('Updated successfuly')

          this.personal.loading = false
        } catch (error) {
          console.log(error.response.data)
          NavVue.show_msg('Can not save user information', 'error')
          this.personal.loading = false
        }
      },

      // get user payments
      async getUserPayments() {
        try {
          // get only_payments
          const only_payments_res = await axios.get(`/api/payments/only_payments`);
          this.payments.only_payments = only_payments_res.data.results
          console.log('payment', only_payments_res.data)
        } catch (error) {
          console.log(error.response.data)
          
        }
      },
      // get user credits
      async getUserCredits() {
        try {
          // get only_credits
          const only_credits_res = await axios.get(`/api/payments/only_credits`);
          this.payments.only_credits = only_credits_res.data.results
          
        } catch (error) {
          console.log(error.response.data)
          
        }
      },



      // oneTimePayment
      // {% if user.profile.non_subscribing_member or user.profile.stripe_subscription_id or user.profile.stripe_customer_id and user.profile.ach_status in 'NEW,VERIFYING' %}
      OPT_ToggleModal() {
        this.oneTimePayment.modalShown = !this.oneTimePayment.modalShown;
      },
      async OPT_Pay() {
        // One time payment pay function
        const oneTimePayment = document.getElementById('oneTimePayment')
        if (oneTimePayment.reportValidity()) {
          this.oneTimePayment.loading = true
  
          // Get stripe card token if user using a card
          if (this.oneTimePayment.paymentMethod == 'CC') {
            stripe.createToken(card).then(async (result) => {
              if (result.error) {
                // Inform the customer that there was an error.
                console.log(result.error.message)
                this.oneTimePayment.stripeError = result.error.message;
                this.oneTimePayment.loading = false
              } else {
                // Send the token to your server.
                this.oneTimePayment.stripeError = null;
                const res = await axios.post('/api/pay/one_time_payment/', {
                  stripeToken: result.token.id,
                  amount: parseFloat(oneTimePayment.amount.value)
                });
                
                // Show success message
                NavVue.show_msg(res.data.detail)
                
                oneTimePayment.reset()
                card.unmount()
                this.oneTimePayment.loading = false
                this.oneTimePayment.modalShown = false
              }
            });
          } else {
            try {
              const res = await axios.post('/api/pay/one_time_payment/', {amount: parseFloat(oneTimePayment.amount.value)});
              NavVue.show_msg(res.data.detail)
              this.oneTimePayment.modalShown = false
            } catch (error) {
              NavVue.show_msg(error.response.data.detail, 'error')
            }
            this.oneTimePayment.loading = false
          }
        }
      },
      // {% endif %}

      // VerifyACH
      // {% if user.profile.payment_method == 'ACH' and user.profile.ach_status == 'NEW' or user.profile.payment_method == 'ACH' and user.profile.ach_status == 'VERIFYING' %}
      async Verify_ACH() {
        const VerifyACH = document.getElementById('VerifyACH');
        if (VerifyACH.reportValidity()) {
          this.VerifyACH.loading = true
  
          try {
            const res = await axios.post('/api/pay/verify_ach_deposits/', {
              amount1: VerifyACH.amount1.value,
              amount2: VerifyACH.amount2.value
            })
  
            NavVue.show_msg(res.data.detail)
            setTimeout(() => location.reload(), 20000)
            
          } catch (error) {
            NavVue.show_msg(error.response.data.detail, 'error')
          }
          this.VerifyACH.loading = false
        }
      },

      // newSubscription
      // {% elif not user.profile.non_subscribing_member and not user.profile.stripe_subscription_id %}
      async subscribe() {
        const newSubscription = document.getElementById('newSubscription');
        if (newSubscription.reportValidity()) {
          this.newSubscription.loading = true;
          fd = new FormData(newSubscription)
          var data = {
            country: 'us',
            currency: 'usd',
            routing_number: fd.get('achRoutingNumber'),
            account_number: fd.get('achAccountNumber'),
            account_holder_name: fd.get('achAccountName'),
            account_holder_type: fd.get('achAccountType')
          }
          promise = stripe.createToken('bank_account', data).then(async (result) => {
            if (result.error) {
              console.log(result.error.message)
              this.newSubscription.stripeError = result.error.message;
            } else {
              this.newSubscription.stripeError = null;
              try {
                const res = await axios.post('/api/pay/subscribe/', {
                  stripeToken: result.token.id,
                  amount: parseFloat(fd.get('amount')),
                  paymentType: fd.get('paymentType')
                });
                // NavVue.show_msg(res.data.detail)
                // setTimeout(() => location.reload(), 10000)
                location.reload()
                // TODO -> store the message in browser and show it after reload
              } catch (error) {
                NavVue.show_msg(error.response.data.detail, 'error')
              }
            }

            this.newSubscription.loading = false;
          })

        }
      },
      // {% endif %}

      // Update password
      async changePassword() {
        const form = document.getElementById(`${this.activeSettings}-form`);
        if (!form.reportValidity()) return
        
        const formData = new FormData(form);

        try {
          this.personal.loading = true
          const res = await axios.post(`/api/users/{{user.id}}/change_password/`, formData);
          NavVue.show_msg('Updated successfuly')
          this.personal.loading = false
          location.reload()
        } catch (error) {
          console.log(error.response.data)
          NavVue.show_msg(error.response.data.detail, 'error')
          this.personal.loading = false
        }
      },


      acceptPhoneNumber(e) {
        // accept only numbers and format them like 999-999-9999
        const x = this.user.profile.phone_number.replace(/\D/g, '').match(/(\d{0,3})(\d{0,3})(\d{0,4})/);
        this.user.profile.phone_number = !x[2] ? x[1] : x[1] + '-' + x[2] + (x[3] ? '-' + x[3] : '');
      },
      acceptPhoneNumber2(e) {
        // accept only numbers and format them like 999-999-9999
        const x = this.user.profile.phone_number_2.replace(/\D/g, '').match(/(\d{0,3})(\d{0,3})(\d{0,4})/);
        this.user.profile.phone_number_2 = !x[2] ? x[1] : x[1] + '-' + x[2] + (x[3] ? '-' + x[3] : '');
      },
      updateActiveSettings(e) {
        this.activeSettings = e.target.id;
        console.log()
      }
    },

    watch: {
      // Onetime Payment
      'oneTimePayment.paymentMethod': function(val) {
        // mount the card ui elements when method is CC
        if (val == 'CC') {
          card.unmount()
          card.mount('#one-time-payment-card')
        }
      },
      // new subscription
      'newSubscription.paymentMethod': function(val) {
        // mount the card ui elements when method is CC
        if (val == 'CC') {
          card.unmount()
          card.mount('#new-subscription-payment-card')
        }
      },
    },
    
    mounted() {
      this.getUser()
      // this.getUserPayments()
      // this.getUserCredits()
    }
  })
</script>

<script id="initAddressAutoCompelete">
  function initAutoCompelete() {
    // Init address auto compelete

    // container IS finished rendering to the DOM
    const geoXml = new geoXML3.parser()
    geoXml.parse(static_url + 'docs/delivery_area.kml')

    // default bounds
    const defaultBounds = new google.maps.LatLngBounds(new google.maps.LatLng(44.222193, -123.207548))

    const options = {
      bounds: defaultBounds,
      types: ['address'],
    }

    const addressInput = document.getElementById('address')
    const autocomplete = new google.maps.places.Autocomplete(addressInput, options)
    autocomplete.addListener('place_changed', function () {
      const place = autocomplete.getPlace();
      if (!place) {
        // return error message
      }

      // Set delivery_address value
      AccountVue.user.profile.delivery_address = place.formatted_address

      let success = false

      for (var i = 0; i < geoXml.docs[0].gpolygons.length; i++) {
        if (google.maps.geometry.poly.containsLocation(place.geometry.location, geoXml.docs[0].gpolygons[i])) {
          success = true

          // Check if we are maxed out for the zip code
          zip = null
          place.address_components.forEach(function (c) {
            if (c.types.includes('postal_code')) {
              zip = c.long_name
              return
            }
          })

          $.ajax('/zip-check/' + zip)
          .done(function (data) {
            if (data.is_full) {
              success = false
              NavVue.show_msg('Unfortunately, our delivery route is full and we can not offer home delivery to your zip code at this time. Please check again at a later date as members change drop sites from time-to-time. You can also <a href="mailto:fullfarmcsa@deckfamilyfarm.com">contact us</a> to be notified when a spot opens up!', 'error')
            }
          })
          .fail(function () {
            success = false
            NavVue.show_msg('An error occurred. Please try again later. Please <a href="mailto:fullfarmcsa@deckfamilyfarm.com">contact us</a> if this problem persists.', 'error')
          })
        }
      }
      
      // we don't deliver to this address
      if (!success) {
        NavVue.show_msg('We do not currently offer delivery service to this address. Please <a class="text-blue-500" href="mailto:fullfarmcsa@deckfamilyfarm.com">contact us</a> to be notified when our delivery options expand.', 'error')
      }
    })
  }
</script>
{% endblock %}